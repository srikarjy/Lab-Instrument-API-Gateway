#!/bin/bash

# Pre-commit hook to prevent committing sensitive data
# Place this file in .git/hooks/pre-commit and make it executable

set -e

echo "ðŸ” Running security checks before commit..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_error() {
    echo -e "${RED}âŒ ERROR: $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸  WARNING: $1${NC}"
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

# Check for sensitive patterns in staged files
check_sensitive_data() {
    local found_issues=0
    
    # Patterns to check for
    local patterns=(
        "password\s*=\s*['\"][^'\"]*['\"]"
        "secret\s*=\s*['\"][^'\"]*['\"]"
        "api[_-]?key\s*=\s*['\"][^'\"]*['\"]"
        "private[_-]?key"
        "BEGIN\s+(RSA\s+)?PRIVATE\s+KEY"
        "jwt[_-]?secret"
        "database[_-]?url\s*=\s*['\"].*://.*:.*@"
        "connection[_-]?string\s*=\s*['\"].*password="
        "aws[_-]?access[_-]?key"
        "aws[_-]?secret"
        "AKIA[0-9A-Z]{16}"
        "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
    )
    
    # Get list of staged files
    local staged_files=$(git diff --cached --name-only --diff-filter=ACM)
    
    if [ -z "$staged_files" ]; then
        print_success "No files to check"
        return 0
    fi
    
    echo "ðŸ” Checking staged files for sensitive data..."
    
    for file in $staged_files; do
        if [ -f "$file" ]; then
            # Skip binary files
            if file "$file" | grep -q "binary"; then
                continue
            fi
            
            # Check each pattern
            for pattern in "${patterns[@]}"; do
                if grep -iE "$pattern" "$file" > /dev/null 2>&1; then
                    print_error "Potential sensitive data found in $file"
                    echo "  Pattern: $pattern"
                    grep -inE "$pattern" "$file" | head -3
                    found_issues=1
                fi
            done
        fi
    done
    
    return $found_issues
}

# Check for large files
check_large_files() {
    local max_size=10485760  # 10MB in bytes
    local found_large=0
    
    echo "ðŸ“ Checking for large files..."
    
    local staged_files=$(git diff --cached --name-only --diff-filter=ACM)
    
    for file in $staged_files; do
        if [ -f "$file" ]; then
            local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
            if [ "$file_size" -gt "$max_size" ]; then
                print_warning "Large file detected: $file ($(($file_size / 1024 / 1024))MB)"
                found_large=1
            fi
        fi
    done
    
    if [ $found_large -eq 0 ]; then
        print_success "No large files found"
    fi
    
    return $found_large
}

# Check for TODO/FIXME comments in production code
check_todos() {
    local found_todos=0
    
    echo "ðŸ“ Checking for TODO/FIXME comments..."
    
    local staged_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(go|js|ts|py|java|cpp|c|h)$')
    
    for file in $staged_files; do
        if [ -f "$file" ]; then
            if grep -inE "(TODO|FIXME|HACK|XXX)" "$file" > /dev/null 2>&1; then
                print_warning "TODO/FIXME found in $file"
                grep -inE "(TODO|FIXME|HACK|XXX)" "$file" | head -3
                found_todos=1
            fi
        fi
    done
    
    if [ $found_todos -eq 0 ]; then
        print_success "No TODO/FIXME comments found"
    fi
    
    return 0  # Don't block commit for TODOs, just warn
}

# Check Go code formatting
check_go_format() {
    local go_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$')
    
    if [ -z "$go_files" ]; then
        return 0
    fi
    
    echo "ðŸ”§ Checking Go code formatting..."
    
    local unformatted_files=""
    for file in $go_files; do
        if [ -f "$file" ]; then
            if ! gofmt -l "$file" | grep -q "^$"; then
                unformatted_files="$unformatted_files $file"
            fi
        fi
    done
    
    if [ -n "$unformatted_files" ]; then
        print_error "Go files are not formatted:"
        echo "$unformatted_files"
        echo "Run: gofmt -w $unformatted_files"
        return 1
    fi
    
    print_success "Go code is properly formatted"
    return 0
}

# Run security checks
main() {
    local exit_code=0
    
    echo "ðŸš€ Starting pre-commit security checks..."
    echo
    
    # Run all checks
    if ! check_sensitive_data; then
        exit_code=1
    fi
    
    echo
    
    if ! check_large_files; then
        # Large files are warnings, not errors
        :
    fi
    
    echo
    
    check_todos
    
    echo
    
    if ! check_go_format; then
        exit_code=1
    fi
    
    echo
    
    if [ $exit_code -eq 0 ]; then
        print_success "All security checks passed! âœ¨"
        echo
        echo "ðŸ“‹ Security checklist:"
        echo "  âœ… No sensitive data detected"
        echo "  âœ… No large files"
        echo "  âœ… Code is properly formatted"
        echo
    else
        print_error "Security checks failed! Please fix the issues above."
        echo
        echo "ðŸ’¡ Tips:"
        echo "  â€¢ Use environment variables for sensitive data"
        echo "  â€¢ Add sensitive files to .gitignore"
        echo "  â€¢ Use secrets management tools in production"
        echo "  â€¢ Run 'gofmt -w .' to format Go code"
        echo
        exit 1
    fi
}

# Run the main function
main "$@"